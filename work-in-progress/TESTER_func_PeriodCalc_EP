# ---- synthetic_tester_period_fsr.py ----
# adaptive_replay_tester.py
import threading, time as _rt, math, copy
import numpy as np
import pandas as pd
from collections import deque
from pathlib import Path
import matplotlib.pyplot as plt
# ---------- 1) Your AdaptiveFSR (paste exactly as you have it) ----------
# (Shortened here): import your AdaptiveFSR class from your module instead:
# from adaptive_fsr import AdaptiveFSR
# -- BEGIN: paste your AdaptiveFSR here --
class AdaptiveFSR:
    def __init__(self, init_contact=0.2, init_nocontact=1.0,
                 ema_alpha=0.2, hysteresis_frac=0.10,
                 min_contact_ms=60, min_release_ms=60, min_dwell_ms=120,
                 clip_band_min=0.02, clip_band_max=1e6, learn_window_steps=6):
        self.alpha = ema_alpha
        self.hfrac = hysteresis_frac
        self.min_contact = min_contact_ms / 1000.0
        self.min_release = min_release_ms / 1000.0
        self.min_dwell   = min_dwell_ms   / 1000.0
        self.clip_band_min = clip_band_min
        self.clip_band_max = clip_band_max

        self.contact_level   = init_contact
        self.nocontact_level = init_nocontact

        self.curr_min = math.inf
        self.curr_max = -math.inf

        self.min_hist = deque(maxlen=learn_window_steps)
        self.max_hist = deque(maxlen=learn_window_steps)

        self.state = 0
        self.last_change_t = 0.0
        self.last_contact_tentative = None
        self.last_release_tentative = None

        self.mid = None
        self.lower = None
        self.upper = None

# After each confirmed dwell, take the median of recent mins/maxes, then update contact_level 
# and nocontact_level with an EMA (so it adapts step-by-step but doesn’t jitter).
    def _update_levels_from_cycle(self):
        if self.curr_min < math.inf:
            self.min_hist.append(self.curr_min)
        if self.curr_max > -math.inf:
            self.max_hist.append(self.curr_max)

        if len(self.min_hist):
            new_contact = sorted(self.min_hist)[len(self.min_hist)//2]
            self.contact_level = (new_contact if self.contact_level is None
                                  else (1 - self.alpha) * self.contact_level + self.alpha * new_contact)
        if len(self.max_hist):
            new_noc = sorted(self.max_hist)[len(self.max_hist)//2]
            self.nocontact_level = (new_noc if self.nocontact_level is None
                                    else (1 - self.alpha) * self.nocontact_level + self.alpha * new_noc)

        self.curr_min = math.inf
        self.curr_max = -math.inf
# Compute the midpoint and hysteresis band (lower, upper) from the learned levels.
    def _recompute_bands(self):
        if (self.contact_level is None) or (self.nocontact_level is None):
            self.mid = self.lower = self.upper = None
            return
        rng = max(1e-9, abs(self.nocontact_level - self.contact_level))
        band = max(self.clip_band_min, min(self.clip_band_max, self.hfrac * rng))
        self.mid = 0.5 * (self.contact_level + self.nocontact_level)
        self.lower = self.mid - band
        self.upper = self.mid + band

    def update(self, v, t=None):
        """
        v: current raw sensor reading (FSR/pressure)
        t: timestamp in seconds (optional)
        """
        if t is None:
            t = time.perf_counter()

        # track extrema in current dwell
        if v < self.curr_min:
            self.curr_min = v
        if v > self.curr_max:
            self.curr_max = v

        self._recompute_bands()
        dt_since_change = t - self.last_change_t

        # bootstrap
        if self.mid is None:
            if dt_since_change > 0.25:
                self._update_levels_from_cycle()
                self._recompute_bands()
            return self.state, self.lower, self.mid, self.upper

        # hysteresis + debounce + min dwell
        if self.state == 0:  # no-contact
            if v >= self.upper and dt_since_change >= self.min_dwell:
                if self.last_contact_tentative is None:
                    self.last_contact_tentative = t
                elif (t - self.last_contact_tentative) >= self.min_contact:
                    self._update_levels_from_cycle()
                    self.state = 1
                    self.last_change_t = t
                    self.last_contact_tentative = None
                    self.curr_min = v
                    self.curr_max = v
            else:
                self.last_contact_tentative = None
        else:  # contact
            if v <= self.lower and dt_since_change >= self.min_dwell:
                if self.last_release_tentative is None:
                    self.last_release_tentative = t
                elif (t - self.last_release_tentative) >= self.min_release:
                    self._update_levels_from_cycle()
                    self.state = 0
                    self.last_change_t = t
                    self.last_release_tentative = None
                    self.curr_min = v
                    self.curr_max = v
            else:
                self.last_release_tentative = None

        return self.state, self.lower, self.mid, self.upper
# -- END: AdaptiveFSR --


# === Paste your Period_FSR here (with your current right-heel changes) ===
# from time import perf_counter  <-- we will override perf_counter below with a simulated clock
# ... your Period_FSR definition ...
def Period_FSR(heelR,heelL,toeR,toeL, HPeriod_available_R, HPeriod_available_L,HeelRp, HeelLp,Allexit,TPeriod_available_R, TPeriod_available_L,ToeRp, ToeLp,gaitR, gaitL):
    
     # Right heel
     heelcountR = 0         # Right heel strike count
     heelcountR_flag = 0    # Flag to enable state change
     heelcountTime_R =0     # exact time of strike
     Previous_heelcountTime_R = 0   
     timeHeelR = 0          # period between strike
     timeHeelR_avg = 0      # average of period between last three strikes
     heel_periods_R = deque(maxlen=3) # list for last three periods
     # Left heel
     heelcountL, heelcountL_flag, heelcountTime_L, Previous_heelcountTime_L, timeHeelL, timeHeelL_avg = 0,0,0,0,0,0
     # Right toe
     toecountR, toecountTime_R, Previous_toecountTime_R, timetoeR, timetoeR_avg, forToeR = 0,0,0,0,0,0 
     toecountR_flag = 1   
     # Left toe
     toecountL, toecountTime_L, Previous_toecountTime_L, timetoeL, timetoeL_avg, forToeL = 0,0,0,0,0,0 
     toecountL_flag = 1
     
     try: # add try: to identify problem when the codes fail.
      #print("Came to FSR...", flush=True)
      while not Allexit.value:
        ## Right heel strike #########################################################
         HeelStateR = copy.copy(heelR.value)
        # print("1", flush=True)   
        # HeelStateR indicates heel is touched
         if HeelStateR == 1 and heelcountR_flag == 0:
             heelcountR_flag = 1
             heelcountTime_R = perf_counter() # stores the exact time of heel strike
             if heelcountR == 0:
                  gaitR.value = heelcountTime_R # gaitR is global variable for the exact time of heel strike
             forToeR = copy.copy(heelcountTime_R) # to use in the toe off time calculation
             heelcountR = heelcountR +1  # increase counter by 1
            # Prev_heelcountTime_R = perf_counter()
             #print("here")   
             if heelcountR> 1:
                  time_bet_heel_R = heelcountTime_R - Previous_heelcountTime_R # time between two consecutive heel strikes
                  #timeHeelR = timeHeelR + time_bet_heel_R # running sum of intervals
                  heel_periods_R.append(time_bet_heel_R) # add to the list, autmoatically removes the oldest entry if more than 3
            #### OLD METHOD ####
            #  if heelcountR == 3:
            #      timeHeelR_avg = timeHeelR/3 
            #      timeHeelR = 0
            #      heelcountR = 0 
            #      gaitR.value =  perf_counter()
            #  Previous_heelcountTime_R = heelcountTime_R

              ### NEW METHOD --- START ###
             if len(heel_periods_R) == 3: # when the length of the list reaches 3, start calculating average
                    timeHeelR_avg = sum(heel_periods_R) / 3
                    gaitR.value =  perf_counter()
             Previous_heelcountTime_R = heelcountTime_R
               ### NEW METHOD --- END ###

         if HeelStateR == 0 and heelcountR_flag == 1:
              heelcountR_flag = 0
              # timeHeel is actually the gait period
              #print("here")

         if timeHeelR_avg != 0:
              HPeriod_available_R.value = 1
              HeelRp.value = copy.copy(timeHeelR_avg)
              timeHeelR_avg = 0   
     except Exception as e:
            import traceback
            print("FSR crashed", e , flush=True )
            traceback.print_exc()                  

# --- Minimal mock for multiprocessing.Value-like objects ---
class SharedVal:
    def __init__(self, v=0):
        self.value = v

# --- Simulated monotonic clock to replace perf_counter used inside Period_FSR ---
class SimClock:
    def __init__(self, t0=0.0): self.t = float(t0)
    def now(self): return self.t
    def advance(self, dt): self.t += float(dt)

# ---------- CSV + AdaptiveFSR replay ----------

def run_csv_test(csv_path, time_col=0, fsr_col=1, smoothing_win=5,
                 det_kwargs=None, loop_sleep=0.001):
    det_kwargs = det_kwargs or dict(hysteresis_frac=0.10, min_contact_ms=50,
                                    min_release_ms=50, min_dwell_ms=100)

    df = pd.read_csv(Path(csv_path), header=None, low_memory=False)

    # Time vector
    t = pd.to_numeric(df.iloc[:, time_col], errors="coerce").to_numpy()
    t = t - (t[0] if len(t) else 0.0)
    if np.any(np.diff(t) < 0):
        dt_med = float(np.nanmedian(np.diff(t[np.diff(t) >= 0])))
        if not np.isfinite(dt_med) or dt_med <= 0: dt_med = 0.01
        t = np.arange(len(df)) * dt_med

    # Raw signal (right heel volts)
    v_raw = pd.to_numeric(df.iloc[:, fsr_col], errors="coerce").to_numpy()
    v = v_raw.copy()

    # Optional smoothing for detection (raw stays raw for plotting)
    if smoothing_win and smoothing_win > 1:
        k = int(smoothing_win)
        v = np.convolve(v_raw, np.ones(k)/k, mode="same")

    # Binarise with AdaptiveFSR and capture thresholds
    det = AdaptiveFSR(**det_kwargs)
    det.last_change_t = float(t[0]) if len(t) else 0.0

    state = np.zeros_like(v_raw, dtype=int)
    lower = np.full_like(v_raw, np.nan, dtype=float)
    mid   = np.full_like(v_raw, np.nan, dtype=float)
    upper = np.full_like(v_raw, np.nan, dtype=float)

    for i in range(len(t)):
        s, lo, md, up = det.update(float(v_raw[i]), float(t[i]))
        state[i] = s
        lower[i] = lo if lo is not None else np.nan
        mid[i]   = md if md is not None else np.nan
        upper[i] = up if up is not None else np.nan

    # Heel strikes = rising edges of the binarised state
    trans = np.diff(state, prepend=state[0])
    hs_idx = np.where(trans == 1)[0]
    hs_times = t[hs_idx].tolist()

    # ---- PLOT: raw FSR + thresholds + HS (top)  AND  binarised + HS (bottom) ----
    fig, (ax_top, ax_bot) = plt.subplots(2, 1, figsize=(12, 6), sharex=True, gridspec_kw={'hspace': 0.18})

    # TOP: raw FSR + adaptive thresholds + HS markers on raw
    ax_top.plot(t, v_raw, linewidth=1.0, label="FSR (raw)")
    ax_top.plot(t, mid,   linewidth=1.0, label="Adaptive mid")
    ax_top.plot(t, lower, linewidth=1.0, label="Adaptive lower")
    ax_top.plot(t, upper, linewidth=1.0, label="Adaptive upper")
    if len(hs_idx):
        ax_top.plot(t[hs_idx], v_raw[hs_idx],
                    linestyle="None", marker="o", markersize=5,
                    color="red", label="HS (from 0→1)", zorder=3)
    ax_top.set_title("FSR Right Heel: raw + adaptive thresholds (top), binarised + HS (bottom)")
    ax_top.set_ylabel("FSR voltage (raw)")
    ax_top.legend(loc="best")

    # BOTTOM: binarised state + HS markers at y=1
    ax_bot.step(t, state, where="post", linewidth=1.0, label="Binarised (contact=1)")
    if len(hs_idx):
        ax_bot.plot(t[hs_idx], np.ones_like(hs_idx),
                    linestyle="None", marker="o", markersize=5,
                    color="red", label="HS (from 0→1)", zorder=3)
    ax_bot.set_ylim(-0.1, 1.1)
    ax_bot.set_yticks([0, 1])
    ax_bot.set_yticklabels(["off", "on"])
    ax_bot.set_xlabel("Time (s)")
    ax_bot.set_ylabel("State")
    ax_bot.legend(loc="best")

    plt.tight_layout()
    plt.show()
    # ---- /PLOT ----
    
    # ---- (unchanged) replay into Period_FSR to compute rolling averages ----
    heelR = SharedVal(0); heelL = SharedVal(0)
    toeR  = SharedVal(1); toeL  = SharedVal(1)
    HPeriod_available_R = SharedVal(0); HPeriod_available_L = SharedVal(0)
    TPeriod_available_R = SharedVal(0); TPeriod_available_L = SharedVal(0)
    HeelRp = SharedVal(0.0); HeelLp = SharedVal(0.0)
    ToeRp  = SharedVal(0.0); ToeLp  = SharedVal(0.0)
    gaitR = SharedVal(0.0); gaitL = SharedVal(0.0)
    Allexit = SharedVal(False)

    sim = SimClock(t0=0.0)
    globals()['perf_counter'] = sim.now

    th = threading.Thread(
        target=Period_FSR,
        args=(heelR, heelL, toeR, toeL,
              HPeriod_available_R, HPeriod_available_L, HeelRp, HeelLp,
              Allexit,
              TPeriod_available_R, TPeriod_available_L, ToeRp, ToeLp,
              gaitR, gaitL),
        daemon=True
    )
    th.start()

    emissions = []
    prev = 0.0
    for t_hs in hs_times:
        sim.advance(float(t_hs - prev) + 1e-9)
        prev = float(t_hs)
        heelR.value = 1; _rt.sleep(loop_sleep)
        heelR.value = 0; _rt.sleep(loop_sleep)

        if HPeriod_available_R.value == 1:
            emissions.append((sim.now(), float(HeelRp.value)))
            print(f"[t={sim.now():.3f}] R HS→HS avg(3): {HeelRp.value:.3f} s")
            HPeriod_available_R.value = 0

    Allexit.value = True
    th.join(timeout=1.0)
    print(f"CSV replay complete. HS detected: {len(hs_times)}, emissions: {len(emissions)}")
    return emissions, hs_times


# ---------- Main ----------
if __name__ == "__main__":
    # >>> SET YOUR CSV PATH HERE <<<
    CSV_PATH = "C:/Users/ep15603/OneDrive - University of Bristol/Desktop/VIVO hub/3. STS-Walking device/2. Python scripts/example_FSR_Data.csv"  # col0=time(s), col1=Right Heel FSR volts
    run_csv_test(CSV_PATH, time_col=0, fsr_col=1, smoothing_win=5)
